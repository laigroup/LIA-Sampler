# 采样算法设计
## Q1：如何实现随机化？
### A1：借鉴LS-SAMPLING的算法。

1. LS-SAMPLING 进行 $k$ 轮采样，每轮采样一个样本。

2. 每轮采样首先计算一个**候选样本集合**，计算前根据之前所得样本集的特征对本次变量（文字）进行初始化。

    * 具体来说，引入变量 $x_i$ 被设置为 true 的概率值 $prob(x_i)$。
    * 设 $A$ 为现有有效样本的集合， $B$ 为 $A$ 中 $x_i$ 被设置为 false 的样本集合。
    * 每轮采样初始化时，更新采样概率 $prob(x_i) \leftarrow |B|/|A|$。

3. 每轮在候选集中选择得分最高（不相似性最强）的样本。

4. 在选择 operation 时，根据 $prob(x_i)$ 打破评分并列。

#### A1.1：对 lia 原子的翻转不同于对布尔变量的翻转。
值得注意的是，布尔变量是单值的，所以每次翻转会把仅会把某个布尔变量的取值 flip。

但由于 lia 变量是多值的，且一个 lia 变量可能会出现在多个 lia 原子中。

因此若把 lia 原子抽象为布尔变量，通过 `critical move` 对其进行 flip，可能会导致之前翻转过的变量被重新翻转回去。

如有文字集： $$\{x+y+2 \le 0, \neg x \le 0\} $$
初始变量取值为： $ x= 0, y = 0$

若先对 $x+y+2 \le 0$ 进行操作，选择变量 $x$，通过 `critical move` 操作获得 $x=-2$ ，使得该原子为 true；

再对 $x \le 0$ 进行操作，获得 $x=1$, 使得该原子为 false。

但是通过第二步操作将 $x$ 重新赋值，导致原本被赋为 true 的第一个原子重新翻转为了 false。

#### A1.2：在翻转需要实现翻转为false的方法，还需要决策对哪个 lia 变量进行操作。

#### A1.3：考虑利用随机化的DPLL(T)算法，在命题层面搜索出对原子的赋值。

搜索出随机化的原子赋值之后，在此基础上对原子进行初始化。

#### A1.4：其他策略

**跟踪依赖关系**：当选择翻转某个变量时，首先检查这一翻转是否会影响到其他已经满足的原子。如果会影响，考虑选择一个不会导致已满足条件失效的翻转策略。

**设置约束优先级**：给予不同的约束不同的优先级。在进行翻转决策时，优先保持高优先级约束的满足状态。这可能需要加入更复杂的评估函数。翻转概率大的原子向后放，优先满足。

**回溯策略**：当一个翻转操作导致某些已满足的约束变为不满足时，可以考虑撤销这个操作并尝试其他可能的翻转。这种方法类似于回溯搜索，实现难度较大，开销较大。

**分层搜索**：在对变量进行翻转操作时，可以分层进行。在第一层只考虑那些影响较小的翻转操作，在保持大部分约束不变的情况下尝试达到一个较好的局部最优。之后再在更深的层次上解决那些因初步调整而未满足的约束。

**限制变化幅度**：限制每次变量的改变不超过某个阈值，或确保变量变动后不会使得多个约束同时失效。

**学习策略**：如果某个变量的翻转经常导致多个约束失效，降低其翻转的优先级或频率。

#### A1.5：如何量化样本的多样性或不相似性属性？

考虑从文献 SMT Sampling via Model-Guided Approximation 提出的衡量指标（SMT公式抽象语法树内部节点覆盖率）出发，提出关于多样性的评分函数。

### A2：考虑随机邻域选择。
在小概率下可以随机选择邻域中的点进行搜索，而不是总是选择最优的或是按照固定规则选择。

类似 $\epsilon$-贪心策略。

### A3：考虑使用模拟退火算法跳出局部最优。

模拟退火算法本身带有随机性。
从而算法在初期利用随机性可以跳出局部最优，而在后期则更多地进行局部精细搜索。

### A4：考虑使用遗传算法中的交叉变异策略（SMTSampler）。
* 随机选择两个解的某些部分进行交换（交叉）。
* 随机修改解的某些部分（变异）。

## Q2：如何保证高效求解？
### A1：考虑借鉴Z3++中的启发式评分函数以及两级选择启发式。
这里要权衡随机性和效率。

### A2：考虑选择多个起点进行并行搜索。
如果对比的程序是单线程，对比策略需要考虑。

## Q3：如何短时间内采样大量解？
### A1：考虑在 `critical move` 操作中加入冗余增量或随机步长。

每次在 lia 文字中的移动不再是临界移动，而是在一个区间内做随机采样。

## Q4：是否可以考虑添加全覆盖阶段？
### A1：可以尝试在采样结束后添加全覆盖阶段。 
采样结束后，检查SMT的抽象语法树中哪些内部节点尚未覆盖，并检查是否能在满足约束的前提下进行覆盖。

枚举抽象语法树中所有节点，检查其是否被覆盖，若未被覆盖。

生成覆盖样本 s，其覆盖抽象语法树中尚未覆盖的内部节点。

检查在公式 F 中，s 是否是可满足的。

尝试生成覆盖该节点的样本（调用SMT求解）。

## Q5：如何衡量算法效率？
### A1：考虑相同时间内所生成样本集的覆盖率。
### A2：考虑固定样本数量的覆盖率。
### A3：到达完全覆盖后停止生成。（SamplingCA）

## Q6：如何保证预处理是等价变换，即不会改变解空间？
### A1：归结不可用。

如有 CNF 公式 $(p \lor q) \land (\neg q \lor r) $，其解空间为：

|p    |  q | r  |
|---- |----|----|
|true |t/f |true|
|false|true|t/f |

归结后，有公式 $q \lor r$

对该公式而言已经不存在变量 p，但是不能对 p 进行任意取值，否则会不符合原解空间。

### A2：纯文字法不可用。

纯文字法目的是为尽可能使得子句满足，但若子句中存在纯文字，也可在其不满足的情况下使得子句满足。

如有子句 $p \lor (a+b \le 0)$，p 为纯文字，若 $(a+b \le 0)$ 为true，则 p 可以为 false。

### A3：单元传播规则应该可用。

### A4：考虑文章中提及的 Coprocessor 等价性预处理工具。